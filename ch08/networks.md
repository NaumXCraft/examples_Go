###  "Computer Networks"

#### L1. Физический уровень (Physical Layer) — передача битов по среде

```
| Протокол/Технология           | Описание и ключевые особенности                                             |
|-------------------------------|-----------------------------------------------------------------------------|
| **Ethernet PHY (IEEE 802.3)** | Базовая передача по витой паре/оптоволокну;                                 |
| **WiFi PHY (IEEE 802.11)**    | Радиопередача в 2.4–5 ГГц; OFDM-модуляция; до 600 Мбит/с.                   |
| **SONET/SDH**                 | Синхронная оптическая сеть; TDM-кадрирование; от 51.84 Мбит/с до 40 Гбит/с. | 
| **ADSL**                      | OFDM по телефонным линиям; асимметрия (8 Мбит/с вниз/1 вверх).              |

```
#### L2. Канальный уровень (Data Link Layer) — фреймы и доступ к среде

```
| Протокол                          | Описание и ключевые особенности               | Пример                                          |
|-----------------------------------|-----------------------------------------------|-------------------------------------------------|
| **Ethernet MAC**                  | CSMA/CD; CRC для ошибок; фреймы 46–1500 байт. | Локальные сети: свитчи для VLAN (802.1Q)        |
| **PPP (Point-to-Point Protocol)** | Фрейминг с флагами (0x7E); LCP для настройки. | Диал-ап/DSL: инкапсуляция IP над ADSL.          |
| **802.11 (WiFi MAC)**             | CSMA/CA; RTS/CTS для скрытых терминалов.      | Wi-Fi: инфраструктурный режим с точкой доступа. |
                     |
```
#### L3. Сетевой/Интернет уровень (Network/Internet Layer) — маршрутизация пакетов

```
| Протокол           | Описание и ключевые особенности                   | Пример                                       |
|--------------------|---------------------------------------------------|----------------------------------------------|
| **IP (IPv4/IPv6)** | Без соединения; фрагментация; 32/128-бит адреса.  | Интернет: туннелирование IPv6 в IPv4.        |
| **ICMP**           | Диагностика: ping, traceroute; TTL-экспирация.    | Отладка: MTU-дискавери.                      |
| **OSPF**           | Link-state; flooding; иерархическая кластеризация.| Крупные сети: динамические обновления путей. |
| **BGP**            | Политика для AS; path vector.                     | Backbone: маршрутизация между провайдерами . |
```
#### L4. Транспортный уровень (Transport Layer) — end-to-end доставка

```
| Протокол | Описание и ключевые особенности                                     | Пример |
|----------|---------------------------------------------------------------------|-------------------------------------|
| **TCP**  | Надёжный; sliding window; three-way handshake; AIMD для congestion. | Веб/FTP.                            |
| **UDP**  | Без соединения; демультиплексирование портами.                      | DNS/RTP: быстрые запросы, VoIP.     |
| **RTP**  | Над UDP; timestamps для jitter; RTCP для фидбека.                   | Стриминг: аудио 88 кГц, буферизация.|
| **SCTP** | Мультистриминг; multi-homing.                                       | VoIP: fault-tolerant signaling.     |
```
#### L5. Прикладной уровень (Application Layer) — сервисы пользователей

```
| Протокол | Описание и ключевые особенности                     | Пример                                     |
|----------|-----------------------------------------------------|--------------------------------------------|
| **HTTP** | Request-response; GET/POST; persistent connections. | Веб: fetching HTML+images, caching.        |
| **DNS**  | Иерархический; UDP/TCP; A/MX-записи.                | Разрешение: gethostbyname(), CDN-редирект. |
| **FTP**  | TCP; control (21)/data (20) порты; active/passive.  | Файлы: RETR для скачивания, NAT-проблемы.  |
| **SMTP** | Реле email; MAIL/DATA команды.                      | Почта: MTA-to-MTA, MIME.                   |

```
---
### L2  Канальный уровень (Data Link Layer) — фреймы

```
| Преамбула + SFD |  MAC получателя  |  MAC отправителя  | EtherType | Полезная нагрузка ((Payload) |    FCS    |
| 7 байт + 1 байт |     6 байт       |       6 байт      |   2 байта |        46–1500 байт          |   4 байта |


| EtherType (hex) | Протокол |
| --------------- | -------- |
| 0x0800          | IPv4     |
| 0x86DD          | IPv6     |
| 0x0806          | ARP      |


Реальный кусок Ethernet-фрейма в hex (EtherType = IPv4)

55 55 55 55 55 55 55 D5    ← Преамбула (7 байт) + SFD (последний байт заканчивается на 101011)
00:1A:2B:3C:4D:5E          ← MAC-получатель (6 байт)
00:AA:BB:CC:DD:EE          ← MAC-отправитель (6 байт)
08 00                      ← EtherType = IPv4
45 00 00 3C 12 34 40 00 ... ← Начало IP-пакета
... (ещё много байт IP-пакета)
... (в конце IP-пакета)
00 00 00 00 00 00 ...      ← Padding (если пакет был короткий)
1A 2B 3C 4D                ← FCS (CRC-32) — 4 байта

```

---

### Шаг за шагом — что делает приёмник

1. **Вижу преамбулу и старт**
   Биты: `10101010 10101010 10101010 10101010 10101010 10101010 10101010 10101011`
   → Понял: «Ага, сейчас начнётся кадр!»
   → Отбрасываю эти 8 байт полностью.

2. **Читаю первые 48 бит — кому кадр?**
   Биты: `00000000 00011010 00101011 00111100 01001101 01011110`
   Это MAC = 00:1A:2B:3C:4D:5E
   → Смотрю свой MAC. Допустим, у меня именно такой → «О, это мне!» → продолжаю.
   Если бы не совпадало и не был бы FF:FF:FF:FF:FF:FF — выбросил бы сразу.

3. **Читаю следующие 48 бит — от кого**
   `00000000 10101010 10111011 11001100 11011101 11101110` → 00:AA:BB:CC:DD:EE
   Запоминаю: «Отправитель такой-то» (коммутатор запишет в таблицу).

4. **Вижу EtherType**
   `00001000 00000000` = 0x0800 → «Ага, внутри IPv4-пакет!»
   EtherType тоже потом убираем, сетевому уровню он не нужен.

5. **Принимаю всё до конца и считаю CRC**
   Последние 32 бита: `00011010 00101011 00111100 01001101`
   Пересчитываю CRC по всему кадру (кроме преамбулы и CRC).
   Если совпало → «Кадр целый, не битый!»

6. **Отрезаю всё лишнее**
   Что отрезается навсегда:

    * 8 байт преамбулы
    * 6 байт свой MAC
    * 6 байт чужой MAC
    * 2 байта EtherType
    * 4 байта CRC в конце
    * (если были нули в конце — это padding, тоже выкидываем)

   Осталось только это:

   ```
   45 00 00 3C ...         ← чистый IP-пакет
   ```

7. **Сетевой уровень получает чистый IP-пакет**
   Всё лишнее Ethernet «обвязка» отрезано.
   Канальный уровень отдал сетевому уровню только полезную нагрузку.

---

### Итог простыми словами

Представь, что кадр — это письмо в конверте:

* **Конверт** (Ethernet-заголовок + CRC):
  «Кому: 00:1A:2B:3C:4D:5E, От кого: 00:AA:BB:CC:DD:EE, Тип письма: IPv4, проверка печать 1A2B3C4D»

* **Внутри конверта** — чистое письмо (IP-пакет):
  «Привет, я от 192.168.1.10, иду на 192.168.1.20, вот тебе данные…»

Канальный уровень — это секретарь, который:

1. Видит конверт → открывает.
2. Проверяет, тебе ли адрес.
3. Проверяет, не порвана ли печать.
4. Выбрасывает конверт и все наклейки.
5. Отдаёт только чистый листок (IP-пакет) сетевому уровню.

Всё. Больше от Ethernet ничего не остаётся — сетевой уровень получает абсолютно чистый IP-пакет, как будто его по воздуху передали.

---

### Описания кода программы

* создание go.mod в корне проекта: 
* go mod init myproject
* 
* установка зависимостей:
* go get github.com/google/gopacket 
* go get github.com/google/gopacket/layers 
* go get github.com/google/gopacket/pcap 
* обязательно нужно установить Npcap — библиотека для захвата сетевых пакетов на Windows
