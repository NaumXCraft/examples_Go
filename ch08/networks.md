### Что приходит с провода (физический уровень выдаёт канальному уровню)

```
| Преамбула + SFD |  MAC получателя  |  MAC отправителя  | EtherType | Полезная нагрузка ((Payload) |    FCS    |
| 7 байт + 1 байт |     6 байт       |       6 байт      |   2 байта |        46–1500 байт          |   4 байта |


| EtherType (hex) | Протокол |
| --------------- | -------- |
| 0x0800          | IPv4     |
| 0x86DD          | IPv6     |
| 0x0806          | ARP      |


Реальный кусок Ethernet-фрейма в hex (EtherType = IPv4)

55 55 55 55 55 55 55 D5    ← Преамбула (7 байт) + SFD (последний байт заканчивается на 101011)
00:1A:2B:3C:4D:5E          ← MAC-получатель (6 байт)
00:AA:BB:CC:DD:EE          ← MAC-отправитель (6 байт)
08 00                      ← EtherType = IPv4
45 00 00 3C 12 34 40 00 ... ← Начало IP-пакета
... (ещё много байт IP-пакета)
... (в конце IP-пакета)
00 00 00 00 00 00 ...      ← Padding (если пакет был короткий)
1A 2B 3C 4D                ← FCS (CRC-32) — 4 байта

```

---

### Шаг за шагом — что делает приёмник

1. **Вижу преамбулу и старт**
   Биты: `10101010 10101010 10101010 10101010 10101010 10101010 10101010 10101011`
   → Понял: «Ага, сейчас начнётся кадр!»
   → Отбрасываю эти 8 байт полностью.

2. **Читаю первые 48 бит — кому кадр?**
   Биты: `00000000 00011010 00101011 00111100 01001101 01011110`
   Это MAC = 00:1A:2B:3C:4D:5E
   → Смотрю свой MAC. Допустим, у меня именно такой → «О, это мне!» → продолжаю.
   Если бы не совпадало и не был бы FF:FF:FF:FF:FF:FF — выбросил бы сразу.

3. **Читаю следующие 48 бит — от кого**
   `00000000 10101010 10111011 11001100 11011101 11101110` → 00:AA:BB:CC:DD:EE
   Запоминаю: «Отправитель такой-то» (коммутатор запишет в таблицу).

4. **Вижу EtherType**
   `00001000 00000000` = 0x0800 → «Ага, внутри IPv4-пакет!»
   EtherType тоже потом убираем, сетевому уровню он не нужен.

5. **Принимаю всё до конца и считаю CRC**
   Последние 32 бита: `00011010 00101011 00111100 01001101`
   Пересчитываю CRC по всему кадру (кроме преамбулы и CRC).
   Если совпало → «Кадр целый, не битый!»

6. **Отрезаю всё лишнее**
   Что отрезается навсегда:

    * 8 байт преамбулы
    * 6 байт свой MAC
    * 6 байт чужой MAC
    * 2 байта EtherType
    * 4 байта CRC в конце
    * (если были нули в конце — это padding, тоже выкидываем)

   Осталось только это:

   ```
   45 00 00 3C ...         ← чистый IP-пакет
   ```

7. **Сетевой уровень получает чистый IP-пакет**
   Всё лишнее Ethernet «обвязка» отрезано.
   Канальный уровень отдал сетевому уровню только полезную нагрузку.

---

### Итог простыми словами

Представь, что кадр — это письмо в конверте:

* **Конверт** (Ethernet-заголовок + CRC):
  «Кому: 00:1A:2B:3C:4D:5E, От кого: 00:AA:BB:CC:DD:EE, Тип письма: IPv4, проверка печать 1A2B3C4D»

* **Внутри конверта** — чистое письмо (IP-пакет):
  «Привет, я от 192.168.1.10, иду на 192.168.1.20, вот тебе данные…»

Канальный уровень — это секретарь, который:

1. Видит конверт → открывает.
2. Проверяет, тебе ли адрес.
3. Проверяет, не порвана ли печать.
4. Выбрасывает конверт и все наклейки.
5. Отдаёт только чистый листок (IP-пакет) сетевому уровню.

---


Всё. Больше от Ethernet ничего не остаётся — сетевой уровень получает абсолютно чистый IP-пакет, как будто его по воздуху передали.

### Описания кода программы

* **установка зависимостей**

- go get github.com/google/gopacket
- go get github.com/google/gopacket/layers
- go get github.com/google/gopacket/pcap
- обязательно нужно установить Npcap — библиотека для захвата сетевых пакетов на Windows
